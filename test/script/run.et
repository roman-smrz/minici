module run

import common

asset scripts:
    path: ../asset/run


test RunWithoutRepo:
    node n
    spawn on n as p args [ "--storage=.minici", "${scripts.path}/norepo-basic.yaml", "run", "success", "failure" ]
    expect_result from p:
        of "success" result "done"
        of "failure" result "failed"
    expect /(.*)/ from p capture done
    guard (done == "run-finish")


test RunWithRepo:
    node n
    shell on n as git_init:
        git -c init.defaultBranch=master init -q
        git -c user.name=test -c user.email=test commit -q --allow-empty -m 'initial commit'
        git rev-parse HEAD
        cp "${scripts.path}/repo-basic.yaml" minici.yaml
        git add minici.yaml
        git -c user.name=test -c user.email=test commit -q -m 'basic1'
        git rev-parse HEAD^{tree}
        cp "${scripts.path}/repo-basic2.yaml" minici.yaml
        git add minici.yaml
        git -c user.name=test -c user.email=test commit -q -m 'basic1'
        git rev-parse HEAD
        git rev-parse HEAD^{tree}

    expect /([0-9a-f]+)/ from git_init capture c0
    expect /([0-9a-f]+)/ from git_init capture t1
    expect /([0-9a-f]+)/ from git_init capture c2
    expect /([0-9a-f]+)/ from git_init capture t2

    local:
        spawn on n as p args [ "run", "--range=$c0..$c2" ]
        expect_result from p:
            of "$t1.success" result "done"
            of "$t1.failure" result "failed"

            of "$t2.success" result "done"
            of "$t2.failure" result "failed"
            of "$t2.third" result "done"
            of "$t2.fourth" result "done"

        expect /(.*)/ from p capture done
        guard (done == "run-finish")

    local:
        spawn on n as p args [ "./minici.yaml", "run", "--range=$c0..$c2" ]
        expect_previous_result from p:
            of "$t1.success" result "done"
        expect_result from p:
            of "$t1.failure" result "failed"
            of "$t1.third" result "done"
            of "$t1.fourth" result "done"

        expect_previous_result from p:
            of "$t2.success" result "done"
        expect_result from p:
            of "$t2.failure" result "failed"
        expect_previous_result from p:
            of "$t2.third" result "done"
            of "$t2.fourth" result "done"

        expect /(.*)/ from p capture done
        guard (done == "run-finish")


test RunExternalRepo:
    node n
    shell on n as git_init:
        mkdir -p first/subdir
        git -C first -c init.defaultBranch=master init -q
        git -C first -c user.name=test -c user.email=test commit -q --allow-empty -m 'initial commit'
        touch first/subdir/file
        git -C first add subdir
        git -C first -c user.name=test -c user.email=test commit -q -m 'commit'
        git -C first rev-parse HEAD^{tree}
        git -C first rev-parse HEAD:subdir

        mkdir -p second/sub
        git -C second -c init.defaultBranch=master init -q
        git -C second -c user.name=test -c user.email=test commit -q --allow-empty -m 'initial commit'
        touch second/sub/other
        git -C second add sub
        git -C second -c user.name=test -c user.email=test commit -q -m 'commit'
        git -C second rev-parse HEAD^{tree}
        git -C second rev-parse HEAD:sub

        mkdir -p main
        git -C main -c init.defaultBranch=master init -q
        git -C main -c user.name=test -c user.email=test commit -q --allow-empty -m 'initial commit'
        cp "${scripts.path}/external.yaml" main/minici.yaml
        git -C main add minici.yaml
        git -C main -c user.name=test -c user.email=test commit -q -m 'commit'
        git -C main rev-parse HEAD^{tree}

    expect /([0-9a-f]+)/ from git_init capture first_root
    expect /([0-9a-f]+)/ from git_init capture first_subtree
    expect /([0-9a-f]+)/ from git_init capture second_root
    expect /([0-9a-f]+)/ from git_init capture second_subtree
    expect /([0-9a-f]+)/ from git_init capture main_root

    # Explicit jobfile outside of any git repo
    local:
        spawn on n as p args [ "--repo=first:./first", "--repo=second:./second", "--storage=.minici", "${scripts.path}/external.yaml", "run", "single", "multiple", "combine" ]
        for job in [ "single.$first_root", "multiple.$first_subtree.$second_subtree", "combine.$first_root.$second_subtree" ]:
            expect_success from p of job

        expect /(.*)/ from p capture done
        guard (done == "run-finish")

    # Explicit jobfile within a git repo
    local:
        spawn on n as p args [ "--repo=first:./first", "--repo=second:./second", "--storage=.minici", "${scripts.path}/external.yaml", "run", "single" ]
        expect_success from p of "single.$first_root"
        expect /(.*)/ from p capture done
        guard (done == "run-finish")

    # Implicit jobfile within a git repo
    local:
        spawn on n as p args [ "--repo=first:./first", "--repo=second:./second", "./main", "run", "HEAD^..HEAD" ]
        for job in [ "single.$first_root", "multiple.$first_subtree.$second_subtree", "combine.$first_root.$second_subtree" ]:
            expect_success from p of "$main_root.$job"

        expect /(.*)/ from p capture done
        guard (done == "run-finish")


test RunExplicitJob:
    node n
    shell on n as git_init:
        mkdir -p main
        git -C main -c init.defaultBranch=master init -q
        cp "${scripts.path}/explicit.yaml" main/minici.yaml
        git -C main add minici.yaml
        git -C main -c user.name=test -c user.email=test commit -q --allow-empty -m 'initial commit'

        mkdir -p main/subdir

        touch main/subdir/a
        git -C main add subdir
        git -C main -c user.name=test -c user.email=test commit -q -m 'commit'
        git -C main rev-parse HEAD^{commit}
        git -C main rev-parse HEAD^{tree}

        touch main/subdir/b
        git -C main add subdir
        git -C main -c user.name=test -c user.email=test commit -q -m 'commit'
        git -C main rev-parse HEAD^{tree}

        rm main/subdir/a
        rm main/subdir/b
        touch main/subdir/c
        git -C main add subdir
        git -C main -c user.name=test -c user.email=test commit -q -m 'commit'
        git -C main rev-parse HEAD^{tree}

        touch main/subdir/d
        git -C main add subdir
        git -C main -c user.name=test -c user.email=test commit -q -m 'commit'
        git -C main rev-parse HEAD^{tree}

    expect /([0-9a-f]+)/ from git_init capture c1
    expect /([0-9a-f]+)/ from git_init capture t1
    expect /([0-9a-f]+)/ from git_init capture t2
    expect /([0-9a-f]+)/ from git_init capture t3
    expect /([0-9a-f]+)/ from git_init capture t4

    local:
        spawn on n as p args [ "./main", "run", "$c1.build" ]
        expect_success from p of "$t1.build"
        expect /(.*)/ from p capture done
        guard (done == "run-finish")
    local:
        spawn on n as p args [ "./main", "extract", "$c1.build.out", "list" ]
    local:
        shell on n as s:
            cat list
            rm list
        expect /a/ from s

    local:
        spawn on n as p args [ "./main", "run", "$t2.build" ]
        expect_success from p of "$t2.build"
        expect /(.*)/ from p capture done
        guard (done == "run-finish")
    local:
        spawn on n as p args [ "./main", "extract", "$t2.build.out", "list" ]
    local:
        shell on n as s:
            cat list
            rm list
        expect /a b/ from s

    local:
        spawn on n as p args [ "./main", "run", "HEAD^.build" ]
        expect_success from p of "$t3.build"
        expect /(.*)/ from p capture done
        guard (done == "run-finish")
    local:
        spawn on n as p args [ "./main", "extract", "HEAD^.build.out", "list" ]
    local:
        shell on n as s:
            cat list
            rm list
        expect /c/ from s

    local:
        spawn on n as p args [ "./main", "run", "HEAD.build" ]
        expect_success from p of "$t4.build"
        expect /(.*)/ from p capture done
        guard (done == "run-finish")
    local:
        spawn on n as p args [ "./main", "extract", "HEAD.build.out", "list" ]
    local:
        shell on n as s:
            cat list
            rm list
        expect /c d/ from s


test RunExplicitDependentJob:
    node n
    shell on n as git_init:
        mkdir -p main
        git -C main -c init.defaultBranch=master init -q
        cp "${scripts.path}/dependencies.yaml" main/minici.yaml
        git -C main add minici.yaml
        git -C main -c user.name=test -c user.email=test commit -q --allow-empty -m 'initial commit'

        mkdir -p main/subdir

        touch main/subdir/a
        git -C main add subdir
        git -C main -c user.name=test -c user.email=test commit -q -m 'commit'
        git -C main rev-parse HEAD^{commit}
        git -C main rev-parse HEAD^{tree}

        touch main/subdir/b
        git -C main add subdir
        git -C main -c user.name=test -c user.email=test commit -q -m 'commit'
        git -C main rev-parse HEAD^{tree}

        rm main/subdir/a
        rm main/subdir/b
        touch main/subdir/c
        git -C main add subdir
        git -C main -c user.name=test -c user.email=test commit -q -m 'commit'
        git -C main rev-parse HEAD^{tree}

        touch main/subdir/d
        git -C main add subdir
        git -C main -c user.name=test -c user.email=test commit -q -m 'commit'
        git -C main rev-parse HEAD^{tree}

    expect /([0-9a-f]+)/ from git_init capture c1
    expect /([0-9a-f]+)/ from git_init capture t1
    expect /([0-9a-f]+)/ from git_init capture t2
    expect /([0-9a-f]+)/ from git_init capture t3
    expect /([0-9a-f]+)/ from git_init capture t4

    local:
        spawn on n as p args [ "./main", "run", "$c1.first", "$t2.first", "$t3.fourth", "$c1.fifth", "$c1.fourth", "$c1.third", "$c1.second", "$t4.fifth" ]
        expect_success from p of "$t1.first"
        expect_success from p of "$t1.second"
        expect_success from p of "$t1.third"
        expect_success from p of "$t1.fourth"
        expect_success from p of "$t1.fifth"

        expect_success from p of "$t2.first"

        expect_success from p of "$t3.first"
        expect_success from p of "$t3.second"
        expect_success from p of "$t3.fourth"

        expect_success from p of "$t4.first"
        expect_success from p of "$t4.second"
        expect_success from p of "$t4.third"
        expect_success from p of "$t4.fourth"
        expect_success from p of "$t4.fifth"

        flush from p matching /note .*/
        flush from p matching /job-duplicate .*/
        expect /(.*)/ from p capture done
        guard (done == "run-finish")


test RunRerun:
    node n
    shell on n as git_init:
        mkdir -p main
        git -C main -c init.defaultBranch=master init -q
        git -C main -c user.name=test -c user.email=test commit -q --allow-empty -m 'initial commit'
        cp "${scripts.path}/rerun.yaml" main/minici.yaml
        git -C main add minici.yaml
        git -C main -c user.name=test -c user.email=test commit -q --allow-empty -m 'minici'
        git -C main rev-parse HEAD^{tree}

    expect /([0-9a-f]+)/ from git_init capture t1

    local:
        spawn on n as p args [ "./main", "run", "$t1.third" ]
        expect_success from p of "$t1.first"
        expect_success from p of "$t1.second"
        expect_result from p of "$t1.first_fail" result "failed"
        expect_skip from p of "$t1.second_skip"
        expect_skip from p of "$t1.third"

        flush from p matching /note .*/
        expect /(.*)/ from p capture done
        guard (done == "run-finish")

    local:
        spawn on n as p args [ "./main", "run", "--rerun-explicit", "$t1.second" ]
        expect_previous_success from p of "$t1.first"
        expect_success from p of "$t1.second"

        flush from p matching /note .*/
        expect /(.*)/ from p capture done
        guard (done == "run-finish")

    local:
        spawn on n as p args [ "./main", "run", "--rerun-failed", "$t1.second" ]
        expect_previous_success from p of "$t1.first"
        expect_previous_success from p of "$t1.second"

        flush from p matching /note .*/
        expect /(.*)/ from p capture done
        guard (done == "run-finish")

    local:
        spawn on n as p args [ "./main", "run", "--rerun-all", "$t1.second" ]
        expect_success from p of "$t1.first"
        expect_success from p of "$t1.second"

        flush from p matching /note .*/
        expect /(.*)/ from p capture done
        guard (done == "run-finish")

    local:
        spawn on n as p args [ "./main", "run", "--rerun-none", "$t1.second" ]
        expect_previous_success from p of "$t1.first"
        expect_previous_success from p of "$t1.second"

        flush from p matching /note .*/
        expect /(.*)/ from p capture done
        guard (done == "run-finish")

    local:
        spawn on n as p args [ "./main", "run", "--rerun-explicit", "$t1.third" ]
        expect_previous_success from p of "$t1.first"
        expect_previous_success from p of "$t1.second"
        expect_result from p of "$t1.first_fail" result "failed"
        expect_skip from p of "$t1.second_skip"
        expect_skip from p of "$t1.third"

        flush from p matching /note .*/
        expect /(.*)/ from p capture done
        guard (done == "run-finish")

    local:
        spawn on n as p args [ "./main", "run", "--rerun-failed", "$t1.third" ]
        expect_previous_success from p of "$t1.first"
        expect_previous_success from p of "$t1.second"
        expect_result from p of "$t1.first_fail" result "failed"
        expect_skip from p of "$t1.second_skip"
        expect_skip from p of "$t1.third"

        flush from p matching /note .*/
        expect /(.*)/ from p capture done
        guard (done == "run-finish")

    local:
        spawn on n as p args [ "./main", "run", "--rerun-all", "$t1.third" ]
        expect_success from p of "$t1.first"
        expect_success from p of "$t1.second"
        expect_result from p of "$t1.first_fail" result "failed"
        expect_skip from p of "$t1.second_skip"
        expect_skip from p of "$t1.third"

        flush from p matching /note .*/
        expect /(.*)/ from p capture done
        guard (done == "run-finish")

    local:
        spawn on n as p args [ "./main", "run", "--rerun-none", "$t1.third" ]
        expect_previous_success from p of "$t1.first"
        expect_previous_success from p of "$t1.second"
        expect_previous_result from p of "$t1.first_fail" result "failed"
        expect_skip from p of "$t1.second_skip"
        expect_skip from p of "$t1.third"

        flush from p matching /note .*/
        expect /(.*)/ from p capture done
        guard (done == "run-finish")


test RunWithManyRepos:
    node n
    shell on n as git_init:
        mkdir -p main
        git -C main -c init.defaultBranch=master init -q
        cp "${scripts.path}/many_repos.yaml" main/minici.yaml
        git -C main add minici.yaml
        git -C main -c user.name=test -c user.email=test commit -q --allow-empty -m 'initial commit'
        git -C main rev-parse HEAD
        git -C main rev-parse HEAD^{tree}

        mkdir -p dir_r1
        git -C dir_r1 -c init.defaultBranch=master init -q
        git -C dir_r1 -c user.name=test -c user.email=test commit -q --allow-empty -m 'initial commit'
        touch dir_r1/file_r1
        git -C dir_r1 add file_r1
        git -C dir_r1 -c user.name=test -c user.email=test commit -q --allow-empty -m 'commit r1'
        git -C dir_r1 -c user.name=test -c user.email=test tag tag1 -m tag1
        touch dir_r1/file2_r1
        git -C dir_r1 add file2_r1
        git -C dir_r1 -c user.name=test -c user.email=test commit -q --allow-empty -m 'commit r1'
        git -C dir_r1 rev-parse HEAD
        git -C dir_r1 rev-parse HEAD^{tree}

        mkdir -p dir_r2
        git -C dir_r2 -c init.defaultBranch=master init -q
        git -C dir_r2 -c user.name=test -c user.email=test commit -q --allow-empty -m 'initial commit'
        touch dir_r2/file_r2
        git -C dir_r2 add file_r2
        git -C dir_r2 -c user.name=test -c user.email=test commit -q --allow-empty -m 'commit r2'
        git -C dir_r2 -c user.name=test -c user.email=test tag tag1 -m tag1
        touch dir_r2/file2_r2
        git -C dir_r2 add file2_r2
        git -C dir_r2 -c user.name=test -c user.email=test commit -q --allow-empty -m 'commit r2'
        git -C dir_r2 rev-parse HEAD
        git -C dir_r2 rev-parse HEAD^{tree}

        mkdir -p dir_r3
        git -C dir_r3 -c init.defaultBranch=master init -q
        git -C dir_r3 -c user.name=test -c user.email=test commit -q --allow-empty -m 'initial commit'
        touch dir_r3/file2_r3
        git -C dir_r3 add file2_r3
        git -C dir_r3 -c user.name=test -c user.email=test commit -q --allow-empty -m 'commit r3'
        git -C dir_r3 -c user.name=test -c user.email=test tag tag1 -m tag1
        touch dir_r3/file_r3
        git -C dir_r3 add file_r3
        git -C dir_r3 -c user.name=test -c user.email=test commit -q --allow-empty -m 'commit r3'
        git -C dir_r3 rev-parse HEAD
        git -C dir_r3 rev-parse HEAD^{tree}

        mkdir -p dir_r4
        git -C dir_r4 -c init.defaultBranch=master init -q
        git -C dir_r4 -c user.name=test -c user.email=test commit -q --allow-empty -m 'initial commit'
        touch dir_r4/file_r4
        git -C dir_r4 add file_r4
        git -C dir_r4 -c user.name=test -c user.email=test commit -q --allow-empty -m 'commit r4'
        git -C dir_r4 rev-parse HEAD
        git -C dir_r4 rev-parse HEAD^{tree}

        mkdir -p dir_r5
        git -C dir_r5 -c init.defaultBranch=master init -q
        git -C dir_r5 -c user.name=test -c user.email=test commit -q --allow-empty -m 'initial commit'
        touch dir_r5/file_r5
        git -C dir_r5 add file_r5
        git -C dir_r5 -c user.name=test -c user.email=test commit -q --allow-empty -m 'commit r5'
        git -C dir_r5 rev-parse HEAD
        git -C dir_r5 rev-parse HEAD^{tree}

    expect /([0-9a-f]+)/ from git_init capture mc
    expect /([0-9a-f]+)/ from git_init capture mt
    expect /([0-9a-f]+)/ from git_init capture r1c
    expect /([0-9a-f]+)/ from git_init capture r1t
    expect /([0-9a-f]+)/ from git_init capture r2c
    expect /([0-9a-f]+)/ from git_init capture r2t
    expect /([0-9a-f]+)/ from git_init capture r3c
    expect /([0-9a-f]+)/ from git_init capture r3t
    expect /([0-9a-f]+)/ from git_init capture r4c
    expect /([0-9a-f]+)/ from git_init capture r4t
    expect /([0-9a-f]+)/ from git_init capture r5c
    expect /([0-9a-f]+)/ from git_init capture r5t

    local:
        spawn on n as p args [ "--storage=minici", "--repo=r1:./dir_r1", "--repo=r3:./dir_r3", "--repo=r4:./dir_r4", "--repo=r2:./dir_r2", "--repo=r5:./dir_r5", "--destination=d1:./dest1", "./main", "run", "--rerun-all", "first" ]
        expect_success from p of "$mt.first.$r1t.$r2t.$r3t.$r4t"
        expect /(.*)/ from p capture done
        guard (done == "run-finish")

    local:
        spawn on n as p args [ "--storage=minici", "--repo=r1:./dir_r1", "--repo=r3:./dir_r3", "--repo=r4:./dir_r4", "--repo=r2:./dir_r2", "--repo=r5:./dir_r5", "--destination=d1:./dest1", "./main", "run", "--rerun-all", "$mc.first.$r1c.$r2t.$r3c.$r4t" ]
        expect_success from p of "$mt.first.$r1t.$r2t.$r3t.$r4t"
        expect /(.*)/ from p capture done
        guard (done == "run-finish")

    local:
        spawn on n as p args [ "--storage=minici", "--repo=r1:./dir_r1", "--repo=r3:./dir_r3", "--repo=r4:./dir_r4", "--repo=r2:./dir_r2", "--repo=r5:./dir_r5", "--destination=d1:./dest1", "./main", "run", "--rerun-all", "first_manual_revision" ]
        expect_success from p of "$mt.first_manual_revision.$r1t.$r2t.$r4t"
        expect /(.*)/ from p capture done
        guard (done == "run-finish")

    local:
        spawn on n as p args [ "--storage=minici", "--repo=r1:./dir_r1", "--repo=r3:./dir_r3", "--repo=r4:./dir_r4", "--repo=r2:./dir_r2", "--repo=r5:./dir_r5", "--destination=d1:./dest1", "./main", "run", "--rerun-all", "$mc.first_manual_revision.$r1c.$r2t.$r4t" ]
        expect_success from p of "$mt.first_manual_revision.$r1t.$r2t.$r4t"
        expect /(.*)/ from p capture done
        guard (done == "run-finish")

    local:
        spawn on n as p args [ "--storage=minici", "--repo=r1:./dir_r1", "--repo=r3:./dir_r3", "--repo=r4:./dir_r4", "--repo=r2:./dir_r2", "--repo=r5:./dir_r5", "--destination=d1:./dest1", "./main", "run", "--rerun-all", "dependent" ]
        expect_success from p of "$mt.first.$r1t.$r2t.$r3t.$r4t"
        expect_success from p of "$mt.dependent.$r1t.$r2t.$r3t.$r4t"
        expect /(.*)/ from p capture done
        guard (done == "run-finish")

    local:
        spawn on n as p args [ "--storage=minici", "--repo=r1:./dir_r1", "--repo=r3:./dir_r3", "--repo=r4:./dir_r4", "--repo=r2:./dir_r2", "--repo=r5:./dir_r5", "--destination=d1:./dest1", "./main", "run", "--rerun-all", "$mc.dependent.$r1c.$r2t.$r3c.$r4t" ]
        expect_success from p of "$mt.first.$r1t.$r2t.$r3t.$r4t"
        expect_success from p of "$mt.dependent.$r1t.$r2t.$r3t.$r4t"
        expect /(.*)/ from p capture done
        guard (done == "run-finish")

    local:
        spawn on n as p args [ "--storage=minici", "--repo=r1:./dir_r1", "--repo=r3:./dir_r3", "--repo=r4:./dir_r4", "--repo=r2:./dir_r2", "--repo=r5:./dir_r5", "--destination=d1:./dest1", "./main", "run", "--rerun-all", "dependent_publish" ]
        expect_success from p of "$mt.first.$r1t.$r2t.$r3t.$r4t"
        expect_success from p of "$mt.dependent_publish.$r1t.$r2t.$r3t.$r4t"
        expect /(.*)/ from p capture done
        guard (done == "run-finish")

    local:
        spawn on n as p args [ "--storage=minici", "--repo=r1:./dir_r1", "--repo=r3:./dir_r3", "--repo=r4:./dir_r4", "--repo=r2:./dir_r2", "--repo=r5:./dir_r5", "--destination=d1:./dest1", "./main", "run", "--rerun-all", "transitive" ]
        expect_success from p of "$mt.first.$r1t.$r2t.$r3t.$r4t"
        expect_success from p of "$mt.dependent.$r1t.$r2t.$r3t.$r4t"
        expect_success from p of "$mt.transitive.$r1t.$r2t.$r3t.$r4t"
        expect /(.*)/ from p capture done
        guard (done == "run-finish")

    local:
        spawn on n as p args [ "--storage=minici", "--repo=r1:./dir_r1", "--repo=r3:./dir_r3", "--repo=r4:./dir_r4", "--repo=r2:./dir_r2", "--repo=r5:./dir_r5", "--destination=d1:./dest1", "./main", "run", "--rerun-all", "$mc.transitive.$r1c.$r2t.$r3c.$r4t" ]
        expect_success from p of "$mt.first.$r1t.$r2t.$r3t.$r4t"
        expect_success from p of "$mt.dependent.$r1t.$r2t.$r3t.$r4t"
        expect_success from p of "$mt.transitive.$r1t.$r2t.$r3t.$r4t"
        expect /(.*)/ from p capture done
        guard (done == "run-finish")

    local:
        spawn on n as p args [ "--storage=minici", "--repo=r1:./dir_r1", "--repo=r3:./dir_r3", "--repo=r4:./dir_r4", "--repo=r2:./dir_r2", "--repo=r5:./dir_r5", "--destination=d1:./dest1", "./main", "run", "--rerun-all", "combined" ]
        expect_success from p of "$mt.first.$r1t.$r2t.$r3t.$r4t"
        expect_success from p of "$mt.second.$r2t.$r3t.$r5t"
        expect_success from p of "$mt.combined.$r1t.$r2t.$r3t.$r4t.$r5t"
        expect /(.*)/ from p capture done
        guard (done == "run-finish")

    local:
        spawn on n as p args [ "--storage=minici", "--repo=r1:./dir_r1", "--repo=r3:./dir_r3", "--repo=r4:./dir_r4", "--repo=r2:./dir_r2", "--repo=r5:./dir_r5", "--destination=d1:./dest1", "./main", "run", "--rerun-all", "combined_transitive" ]
        expect_success from p of "$mt.first.$r1t.$r2t.$r3t.$r4t"
        expect_success from p of "$mt.second.$r2t.$r3t.$r5t"
        expect_success from p of "$mt.dependent.$r1t.$r2t.$r3t.$r4t"
        expect_success from p of "$mt.transitive.$r1t.$r2t.$r3t.$r4t"
        expect_success from p of "$mt.combined.$r1t.$r2t.$r3t.$r4t.$r5t"
        expect_success from p of "$mt.combined_transitive.$r1t.$r2t.$r3t.$r4t.$r5t"
        expect /(.*)/ from p capture done
        guard (done == "run-finish")
