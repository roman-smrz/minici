module repo

import common

asset scripts:
    path: ../asset/repo


test RepoSubtree:
    node n
    shell on n as git_init:
        mkdir -p work
        git -C work -c init.defaultBranch=master init -q
        git -C work -c user.name=test -c user.email=test commit -q --allow-empty -m 'initial commit'

        mkdir -p work/first/second
        touch work/first/second/file
        git -C work add first
        git -C work -c user.name=test -c user.email=test commit -q -m 'commit'
        git -C work rev-parse HEAD^{commit}
        git -C work rev-parse HEAD^{tree}
        git -C work rev-parse HEAD:first
        git -C work rev-parse HEAD:first/second

        git clone -q --bare work bare.git

    expect /([0-9a-f]+)/ from git_init capture commit
    expect /([0-9a-f]+)/ from git_init capture root
    expect /([0-9a-f]+)/ from git_init capture sub1
    expect /([0-9a-f]+)/ from git_init capture sub2

    for repo in [ "./work", "./bare.git" ]:
        local:
            spawn as p on n args [ repo, "subtree", commit, "" ]
            expect from p /msg $root/
            expect from p /path (.*)/ capture path
            guard (path == "")

        local:
            spawn as p on n args [ repo, "subtree", commit, "." ]
            expect from p /msg $root/
            expect from p /path (.*)/ capture path
            guard (path == "")

        local:
            spawn as p on n args [ repo, "subtree", commit, "/" ]
            expect from p /msg $root/
            expect from p /path (.*)/ capture path
            guard (path == "")

        local:
            spawn as p on n args [ repo, "subtree", commit, "first" ]
            expect from p /msg $sub1/
            expect from p /path (.*)/ capture path
            guard (path == "first")

        local:
            spawn as p on n args [ repo, "subtree", commit, "./first" ]
            expect from p /msg $sub1/
            expect from p /path (.*)/ capture path
            guard (path == "first")

        local:
            spawn as p on n args [ repo, "subtree", commit, "/first" ]
            expect from p /msg $sub1/
            expect from p /path (.*)/ capture path
            guard (path == "first")

        local:
            spawn as p on n args [ repo, "subtree", commit, "./first/second" ]
            expect from p /msg $sub2/
            expect from p /path (.*)/ capture path
            guard (path == "first/second")

        local:
            spawn as p on n args [ repo, "subtree", commit, "/first/second" ]
            expect from p /msg $sub2/
            expect from p /path (.*)/ capture path
            guard (path == "first/second")

        local:
            spawn as p on n args [ repo, "subtree", "$sub1(first)", "second" ]
            expect from p /msg $sub2/
            expect from p /path (.*)/ capture path
            guard (path == "first/second")

        local:
            spawn as p on n args [ repo, "subtree", "$sub1(first)", "./second" ]
            expect from p /msg $sub2/
            expect from p /path (.*)/ capture path
            guard (path == "first/second")

        local:
            spawn as p on n args [ repo, "subtree", "$sub1(first)", "/second/" ]
            expect from p /msg $sub2/
            expect from p /path (.*)/ capture path
            guard (path == "first/second")


test CheckoutSubtree:
    node n
    shell on n as git_init:
        mkdir -p main
        git -C main -c init.defaultBranch=master init -q
        cp "${scripts.path}/checkout.yaml" main/minici.yaml
        git -C main add minici.yaml
        git -C main -c user.name=test -c user.email=test commit -q --allow-empty -m 'initial commit'
        git -C main rev-parse HEAD
        git -C main rev-parse HEAD^{tree}

        mkdir -p dir_r1
        git -C dir_r1 -c init.defaultBranch=master init -q
        git -C dir_r1 -c user.name=test -c user.email=test commit -q --allow-empty -m 'initial commit'
        touch dir_r1/file
        git -C dir_r1 add .
        git -C dir_r1 -c user.name=test -c user.email=test commit -q --allow-empty -m 'commit r1'
        git -C dir_r1 rev-parse HEAD
        git -C dir_r1 rev-parse HEAD^{tree}

        mkdir -p dir_r2
        git -C dir_r2 -c init.defaultBranch=master init -q
        git -C dir_r2 -c user.name=test -c user.email=test commit -q --allow-empty -m 'initial commit'
        mkdir -p dir_r2/s1
        mkdir -p dir_r2/s2
        touch dir_r2/s1/file1
        touch dir_r2/s2/file2
        git -C dir_r2 add .
        git -C dir_r2 -c user.name=test -c user.email=test commit -q --allow-empty -m 'commit r2'
        git -C dir_r2 rev-parse HEAD
        git -C dir_r2 rev-parse HEAD^{tree}
        git -C dir_r2 rev-parse HEAD^{tree}:s1
        git -C dir_r2 rev-parse HEAD^{tree}:s2

        mkdir -p dir_r3
        git -C dir_r3 -c init.defaultBranch=master init -q
        git -C dir_r3 -c user.name=test -c user.email=test commit -q --allow-empty -m 'initial commit'
        mkdir -p dir_r3/a/b/s1
        mkdir -p dir_r3/a/b/c/s2
        mkdir -p dir_r3/a/b/c/s3
        touch dir_r3/a/b/s1/file1
        touch dir_r3/a/b/c/s2/file2
        touch dir_r3/a/b/c/s3/file3
        git -C dir_r3 add .
        git -C dir_r3 -c user.name=test -c user.email=test commit -q --allow-empty -m 'commit r3'
        git -C dir_r3 rev-parse HEAD
        git -C dir_r3 rev-parse HEAD^{tree}
        git -C dir_r3 rev-parse HEAD^{tree}:a/b
        git -C dir_r3 rev-parse HEAD^{tree}:a/b/s1
        git -C dir_r3 rev-parse HEAD^{tree}:a/b/c
        git -C dir_r3 rev-parse HEAD^{tree}:a/b/c/s2
        git -C dir_r3 rev-parse HEAD^{tree}:a/b/c/s3

    expect /([0-9a-f]+)/ from git_init capture mc
    expect /([0-9a-f]+)/ from git_init capture mt

    expect /([0-9a-f]+)/ from git_init capture r1c
    expect /([0-9a-f]+)/ from git_init capture r1t

    expect /([0-9a-f]+)/ from git_init capture r2c
    expect /([0-9a-f]+)/ from git_init capture r2t
    expect /([0-9a-f]+)/ from git_init capture r2s1
    expect /([0-9a-f]+)/ from git_init capture r2s2

    expect /([0-9a-f]+)/ from git_init capture r3c
    expect /([0-9a-f]+)/ from git_init capture r3t
    expect /([0-9a-f]+)/ from git_init capture r3ab
    expect /([0-9a-f]+)/ from git_init capture r3abs1
    expect /([0-9a-f]+)/ from git_init capture r3abc
    expect /([0-9a-f]+)/ from git_init capture r3abcs2
    expect /([0-9a-f]+)/ from git_init capture r3abcs3

    local:
        spawn on n as p args [ "--storage=minici", "--repo=r1:./dir_r1", "--repo=r2:./dir_r2", "--repo=r3:./dir_r3", "./main", "run", "--rerun-all", "checkout_subtree" ]
        expect_success from p of "$mt.checkout_subtree.$r1t.$r2s1"
        expect /(.*)/ from p capture done
        guard (done == "run-finish")
    local:
        spawn on n as p args [ "--storage=minici", "--repo=r1:./dir_r1", "--repo=r2:./dir_r2", "--repo=r3:./dir_r3", "./main", "run", "--rerun-all", "$mt.checkout_subtree.$r1t.$r2s1" ]
        expect_success from p of "$mt.checkout_subtree.$r1t.$r2s1"
        expect /(.*)/ from p capture done
        guard (done == "run-finish")
    local:
        spawn on n as p args [ "--storage=minici", "--repo=r1:./dir_r1", "--repo=r2:./dir_r2", "--repo=r3:./dir_r3", "./main", "extract", "$mt.checkout_subtree.$r1t.$r2s1.out", "list" ]
    local:
        shell on n as list:
            cat list
            rm list
            echo DONE
        expect from list:
            /\.\/d1\/file/
            /\.\/d2_s1\/file1/
            /(.*)/ capture done
        guard (done == "DONE")

    local:
        spawn on n as p args [ "--storage=minici", "--repo=r1:./dir_r1", "--repo=r2:./dir_r2", "--repo=r3:./dir_r3", "./main", "run", "--rerun-all", "checkout_common_root" ]
        expect_success from p of "$mt.checkout_common_root.$r1t.$r2t"
        expect /(.*)/ from p capture done
        guard (done == "run-finish")
    local:
        spawn on n as p args [ "--storage=minici", "--repo=r1:./dir_r1", "--repo=r2:./dir_r2", "--repo=r3:./dir_r3", "./main", "run", "--rerun-all", "$mt.checkout_common_root.$r1t.$r2t" ]
        expect_success from p of "$mt.checkout_common_root.$r1t.$r2t"
        expect /(.*)/ from p capture done
        guard (done == "run-finish")
    local:
        spawn on n as p args [ "--storage=minici", "--repo=r1:./dir_r1", "--repo=r2:./dir_r2", "--repo=r3:./dir_r3", "./main", "extract", "$mt.checkout_common_root.$r1t.$r2t.out", "list" ]
    local:
        shell on n as list:
            cat list
            rm list
            echo DONE
        expect from list:
            /\.\/d1\/file/
            /\.\/d2_s1\/file1/
            /\.\/d2_s2\/file2/
            /(.*)/ capture done
        guard (done == "DONE")

    local:
        spawn on n as p args [ "--storage=minici", "--repo=r1:./dir_r1", "--repo=r2:./dir_r2", "--repo=r3:./dir_r3", "./main", "run", "--rerun-all", "checkout_common_subtree" ]
        expect_success from p of "$mt.checkout_common_subtree.$r3ab"
        expect /(.*)/ from p capture done
        guard (done == "run-finish")
    local:
        spawn on n as p args [ "--storage=minici", "--repo=r1:./dir_r1", "--repo=r2:./dir_r2", "--repo=r3:./dir_r3", "./main", "run", "--rerun-all", "$mt.checkout_common_subtree.$r3ab" ]
        expect_success from p of "$mt.checkout_common_subtree.$r3ab"
        expect /(.*)/ from p capture done
        guard (done == "run-finish")
    local:
        spawn on n as p args [ "--storage=minici", "--repo=r1:./dir_r1", "--repo=r2:./dir_r2", "--repo=r3:./dir_r3", "./main", "extract", "$mt.checkout_common_subtree.$r3ab.out", "list" ]
    local:
        shell on n as list:
            cat list
            rm list
            echo DONE
        expect from list:
            /\.\/d3_s1\/file1/
            /\.\/d3_s2\/file2/
            /(.*)/ capture done
        guard (done == "DONE")

    local:
        spawn on n as p args [ "--storage=minici", "--repo=r1:./dir_r1", "--repo=r2:./dir_r2", "--repo=r3:./dir_r3", "./main", "run", "--rerun-all", "checkout_common_subtree2" ]
        expect_success from p of "$mt.checkout_common_subtree2.$r1t.$r2s1.$r3abc"
        expect /(.*)/ from p capture done
        guard (done == "run-finish")
    local:
        spawn on n as p args [ "--storage=minici", "--repo=r1:./dir_r1", "--repo=r2:./dir_r2", "--repo=r3:./dir_r3", "./main", "run", "--rerun-all", "$mt.checkout_common_subtree2.$r1t.$r2s1.$r3abc" ]
        expect_success from p of "$mt.checkout_common_subtree2.$r1t.$r2s1.$r3abc"
        expect /(.*)/ from p capture done
        guard (done == "run-finish")
    local:
        spawn on n as p args [ "--storage=minici", "--repo=r1:./dir_r1", "--repo=r2:./dir_r2", "--repo=r3:./dir_r3", "./main", "extract", "$mt.checkout_common_subtree2.$r1t.$r2s1.$r3abc.out", "list" ]
    local:
        shell on n as list:
            cat list
            rm list
            echo DONE
        expect from list:
            /\.\/d1\/file/
            /\.\/d2_s1\/file1/
            /\.\/d3_s2\/file2/
            /\.\/d3_s3\/file3/
            /(.*)/ capture done
        guard (done == "DONE")

    local:
        spawn on n as p args [ "--storage=minici", "--repo=r1:./dir_r1", "--repo=r2:./dir_r2", "--repo=r3:./dir_r3", "./main", "run", "--rerun-all", "combined_subtree" ]
        expect_success from p of "$mt.checkout_common_root.$r1t.$r2t"
        expect_success from p of "$mt.checkout_common_subtree2.$r1t.$r2s1.$r3abc"
        expect_success from p of "$mt.combined_subtree.$r1t.$r2t.$r3abc"
        expect /(.*)/ from p capture done
        guard (done == "run-finish")
    local:
        spawn on n as p args [ "--storage=minici", "--repo=r1:./dir_r1", "--repo=r2:./dir_r2", "--repo=r3:./dir_r3", "./main", "run", "--rerun-all", "$mt.combined_subtree.$r1t.$r2t.$r3abc" ]
        expect_success from p of "$mt.checkout_common_root.$r1t.$r2t"
        expect_success from p of "$mt.checkout_common_subtree2.$r1t.$r2s1.$r3abc"
        expect_success from p of "$mt.combined_subtree.$r1t.$r2t.$r3abc"
        expect /(.*)/ from p capture done
        guard (done == "run-finish")
    local:
        spawn on n as p args [ "--storage=minici", "--repo=r1:./dir_r1", "--repo=r2:./dir_r2", "--repo=r3:./dir_r3", "./main", "extract", "$mt.combined_subtree.$r1t.$r2t.$r3abc.out", "list" ]
    local:
        shell on n as list:
            cat list
            rm list
            echo DONE
        expect from list:
            /\.\/minici.yaml/
            /\.\/list2/
            /\.\/list4/
            /(.*)/ capture done
        guard (done == "DONE")
